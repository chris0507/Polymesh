use pallet_balances::Call as BalancesCall;
use pallet_transaction_payment::{
    ChargeTransactionPayment, Multiplier, RuntimeDispatchInfo, Trait,
};
use polymesh_common_utilities::{
    traits::{
        asset::AcceptTransfer,
        balances::{AccountData, CheckCdd},
        identity::IdentityTrait,
        transaction_payment::{CddAndFeeDetails, ChargeTxFee},
        CommonTrait,
    },
    SystematicIssuers,
};
use polymesh_primitives::{IdentityId, Permission, Signatory};

use codec::Encode;
use frame_support::{
    dispatch::DispatchResult,
    impl_outer_dispatch, impl_outer_event, impl_outer_origin, parameter_types,
    traits::{Currency, Get},
    weights::{
        DispatchClass, DispatchInfo, GetDispatchInfo, Pays, PostDispatchInfo, Weight,
        WeightToFeeCoefficient, WeightToFeeCoefficients, WeightToFeePolynomial,
    },
};
use smallvec::smallvec;
use sp_core::H256;
use sp_runtime::{
    testing::{Header, TestXt},
    traits::{BlakeTwo256, IdentityLookup, SignedExtension},
    transaction_validity::{InvalidTransaction, TransactionValidity, ValidTransaction},
    FixedPointNumber, Perbill,
};
use std::cell::RefCell;

pub type AccountId = u64;
pub type Balance = u128;

const CALL: &<Runtime as frame_system::Trait>::Call =
    &Call::Balances(BalancesCall::transfer(2, 69));

impl_outer_dispatch! {
    pub enum Call for Runtime where origin: Origin {
        pallet_balances::Balances,
        frame_system::System,
    }
}

impl_outer_event! {
    pub enum Event for Runtime {
        system<T>,
        pallet_balances<T>,
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct Runtime;

use frame_system as system;
impl_outer_origin! {
    pub enum Origin for Runtime {}
}

parameter_types! {
    pub const BlockHashCount: u32 = 250;
    pub const MaximumBlockWeight: u64 = 4096;
    pub const MaximumBlockLength: u32 = 4096;
    pub const AvailableBlockRatio: Perbill = Perbill::from_percent(75);
    pub const MaximumExtrinsicWeight: u64 = 2800;
    pub const BlockExecutionWeight: u64 = 10;
}

thread_local! {
    static EXTRINSIC_BASE_WEIGHT: RefCell<u64> = RefCell::new(0);
}

pub struct ExtrinsicBaseWeight;
impl Get<u64> for ExtrinsicBaseWeight {
    fn get() -> u64 {
        EXTRINSIC_BASE_WEIGHT.with(|v| *v.borrow())
    }
}

impl frame_system::Trait for Runtime {
    /// The basic call filter to use in dispatchable.
    type BaseCallFilter = ();
    /// The identifier used to distinguish between accounts.
    type AccountId = AccountId;
    /// The aggregated dispatch type that is available for extrinsics.
    type Call = Call;
    /// The lookup mechanism to get account ID from whatever is passed in dispatchers.
    type Lookup = IdentityLookup<Self::AccountId>;
    /// The index type for storing how many extrinsics an account has signed.
    type Index = u64;
    /// The index type for blocks.
    type BlockNumber = u64;
    /// The type for hashing blocks and tries.
    type Hash = H256;
    /// The hashing algorithm used.
    type Hashing = BlakeTwo256;
    /// The header type.
    type Header = Header;
    /// The ubiquitous event type.
    type Event = Event;
    /// The ubiquitous origin type.
    type Origin = Origin;
    /// Maximum number of block number to block hash mappings to keep (oldest pruned first).
    type BlockHashCount = BlockHashCount;
    /// Maximum weight of each block.
    type MaximumBlockWeight = MaximumBlockWeight;
    /// Maximum size of all encoded transactions (in bytes) that are allowed in one block.
    type MaximumBlockLength = MaximumBlockLength;
    /// Portion of the block weight that is available to all normal transactions.
    type AvailableBlockRatio = AvailableBlockRatio;
    /// Version of the runtime.
    type Version = ();
    /// Converts a module to the index of the module in `construct_runtime!`.
    ///
    /// This type is being generated by `construct_runtime!`.
    type ModuleToIndex = ();
    /// What to do if a new account is created.
    type OnNewAccount = ();
    /// What to do if an account is fully reaped from the system.
    type OnKilledAccount = ();
    /// The data to be stored in an account.
    type AccountData = AccountData<Balance>;
    /// The weight of database operations that the runtime can invoke.
    type DbWeight = ();
    /// The weight of the overhead invoked on the block import process, independent of the
    /// extrinsics included in that block.
    type BlockExecutionWeight = BlockExecutionWeight;
    /// The base weight of any extrinsic processed by the runtime, independent of the
    /// logic of that extrinsic. (Signature verification, nonce increment, fee, etc...)
    type ExtrinsicBaseWeight = ExtrinsicBaseWeight;
    /// The maximum weight that a single extrinsic of `Normal` dispatch class can have,
    /// independent of the logic of that extrinsics. (Roughly max block weight - average on
    /// initialize cost).
    type MaximumExtrinsicWeight = MaximumExtrinsicWeight;
}

parameter_types! {
    pub const ExistentialDeposit: u128 = 1;
}

impl CommonTrait for Runtime {
    type Balance = Balance;
    type AcceptTransferTarget = Runtime;
    type BlockRewardsReserve = pallet_balances::Module<Runtime>;
}

parameter_types! {
    pub const MinimumPeriod: u64 = 3;
}

impl pallet_balances::Trait for Runtime {
    type DustRemoval = ();
    type Event = Event;
    type ExistentialDeposit = ExistentialDeposit;
    type AccountStore = frame_system::Module<Runtime>;
    type Identity = Runtime;
    type CddChecker = Runtime;
}

impl CheckCdd<AccountId> for Runtime {
    fn check_key_cdd(_key: &AccountId) -> bool {
        true
    }

    fn get_key_cdd_did(_key: &AccountId) -> Option<IdentityId> {
        None
    }
}

thread_local! {
    static TRANSACTION_BYTE_FEE: RefCell<u128> = RefCell::new(1);
    static WEIGHT_TO_FEE: RefCell<u128> = RefCell::new(1);
}

impl CddAndFeeDetails<AccountId, Call> for Runtime {
    fn get_valid_payer(
        _: &Call,
        caller: &Signatory<AccountId>,
    ) -> Result<Option<Signatory<AccountId>>, InvalidTransaction> {
        Ok(Some(*caller))
    }
    fn clear_context() {}
    fn set_payer_context(_: Option<Signatory<AccountId>>) {}
    fn get_payer_from_context() -> Option<Signatory<AccountId>> {
        Some(Signatory::Account(2))
    }
    fn set_current_identity(_: &IdentityId) {}
}

impl IdentityTrait<AccountId> for Runtime {
    fn get_identity(_key: &AccountId) -> Option<IdentityId> {
        unimplemented!()
    }
    fn current_payer() -> Option<Signatory<AccountId>> {
        None
    }
    fn current_identity() -> Option<IdentityId> {
        unimplemented!()
    }
    fn set_current_identity(_id: Option<IdentityId>) {
        unimplemented!()
    }
    fn set_current_payer(_payer: Option<Signatory<AccountId>>) {}
    fn is_signer_authorized(_did: IdentityId, _signer: &Signatory<AccountId>) -> bool {
        unimplemented!()
    }
    fn is_signer_authorized_with_permissions(
        _did: IdentityId,
        _signer: &Signatory<AccountId>,
        _permissions: Vec<Permission>,
    ) -> bool {
        unimplemented!()
    }
    fn is_master_key(_did: IdentityId, _key: &AccountId) -> bool {
        unimplemented!()
    }

    fn unsafe_add_systematic_cdd_claims(_targets: &[IdentityId], _issuer: SystematicIssuers) {}
    fn unsafe_revoke_systematic_cdd_claims(_targets: &[IdentityId], _issuer: SystematicIssuers) {}
    fn has_valid_cdd(_target_did: IdentityId) -> bool {
        unimplemented!()
    }
}

impl AcceptTransfer for Runtime {
    fn accept_ticker_transfer(_: IdentityId, _: u64) -> DispatchResult {
        Ok(())
    }
    fn accept_asset_ownership_transfer(_: IdentityId, _: u64) -> DispatchResult {
        Ok(())
    }
}
pub struct TransactionByteFee;
impl Get<u128> for TransactionByteFee {
    fn get() -> u128 {
        TRANSACTION_BYTE_FEE.with(|v| *v.borrow())
    }
}
pub struct WeightToFee;
impl WeightToFeePolynomial for WeightToFee {
    type Balance = Balance;

    fn polynomial() -> WeightToFeeCoefficients<Self::Balance> {
        smallvec![WeightToFeeCoefficient {
            degree: 1,
            coeff_frac: Perbill::zero(),
            coeff_integer: WEIGHT_TO_FEE.with(|v| *v.borrow()),
            negative: false,
        }]
    }
}

impl Trait for Runtime {
    type Currency = pallet_balances::Module<Runtime>;
    type OnTransactionPayment = ();
    type TransactionByteFee = TransactionByteFee;
    type WeightToFee = WeightToFee;
    type FeeMultiplierUpdate = ();
    type CddHandler = Runtime;
}

impl ChargeTxFee for Runtime {
    fn charge_fee(_len: u32, _info: DispatchInfo) -> TransactionValidity {
        Ok(ValidTransaction::default())
    }
}

type Balances = pallet_balances::Module<Runtime>;
type System = frame_system::Module<Runtime>;
type TransactionPayment = pallet_transaction_payment::Module<Runtime>;

pub struct ExtBuilder {
    balance_factor: u128,
    base_weight: u64,
    byte_fee: u128,
    weight_to_fee: u128,
}

impl Default for ExtBuilder {
    fn default() -> Self {
        Self {
            balance_factor: 1,
            base_weight: 0,
            byte_fee: 1,
            weight_to_fee: 1,
        }
    }
}

impl ExtBuilder {
    pub fn base_weight(mut self, base_weight: u64) -> Self {
        self.base_weight = base_weight;
        self
    }
    pub fn byte_fee(mut self, byte_fee: u128) -> Self {
        self.byte_fee = byte_fee;
        self
    }
    pub fn weight_fee(mut self, weight_to_fee: u128) -> Self {
        self.weight_to_fee = weight_to_fee;
        self
    }
    pub fn balance_factor(mut self, factor: u128) -> Self {
        self.balance_factor = factor;
        self
    }
    fn set_constants(&self) {
        EXTRINSIC_BASE_WEIGHT.with(|v| *v.borrow_mut() = self.base_weight);
        TRANSACTION_BYTE_FEE.with(|v| *v.borrow_mut() = self.byte_fee);
        WEIGHT_TO_FEE.with(|v| *v.borrow_mut() = self.weight_to_fee);
    }
    pub fn build(self) -> sp_io::TestExternalities {
        self.set_constants();
        let mut t = frame_system::GenesisConfig::default()
            .build_storage::<Runtime>()
            .unwrap();
        pallet_balances::GenesisConfig::<Runtime> {
            balances: if self.balance_factor > 0 {
                vec![
                    (1, 10 * self.balance_factor),
                    (2, 20 * self.balance_factor),
                    (3, 30 * self.balance_factor),
                    (4, 40 * self.balance_factor),
                    (5, 50 * self.balance_factor),
                    (6, 60 * self.balance_factor),
                ]
            } else {
                vec![]
            },
            identity_balances: vec![],
        }
        .assimilate_storage(&mut t)
        .unwrap();
        t.into()
    }
}

/// create a transaction info struct from weight. Handy to avoid building the whole struct.
pub fn info_from_weight(w: Weight) -> DispatchInfo {
    // pays_fee: Pays::Yes -- class: DispatchClass::Normal
    DispatchInfo {
        weight: w,
        ..Default::default()
    }
}

fn post_info_from_weight(w: Weight) -> PostDispatchInfo {
    PostDispatchInfo {
        actual_weight: Some(w),
    }
}

fn default_post_info() -> PostDispatchInfo {
    PostDispatchInfo {
        actual_weight: None,
    }
}

#[test]
fn signed_extension_transaction_payment_work() {
    ExtBuilder::default()
        .balance_factor(10)
        .base_weight(5)
        .build()
        .execute_with(|| {
            let len = 10;
            let pre = ChargeTransactionPayment::<Runtime>::from(0)
                .pre_dispatch(&1, CALL, &info_from_weight(5), len)
                .unwrap();
            assert_eq!(Balances::free_balance(1), 100 - 5 - 5 - 10);

            assert!(ChargeTransactionPayment::<Runtime>::post_dispatch(
                pre,
                &info_from_weight(5),
                &default_post_info(),
                len,
                &Ok(())
            )
            .is_ok());
            assert_eq!(Balances::free_balance(1), 100 - 5 - 5 - 10);

            let pre = ChargeTransactionPayment::<Runtime>::from(0 /* tipped */)
                .pre_dispatch(&2, CALL, &info_from_weight(100), len)
                .unwrap();
            assert_eq!(Balances::free_balance(2), 200 - 5 - 10 - 100 - 0);

            assert!(ChargeTransactionPayment::<Runtime>::post_dispatch(
                pre,
                &info_from_weight(100),
                &post_info_from_weight(50),
                len,
                &Ok(())
            )
            .is_ok());
            assert_eq!(Balances::free_balance(2), 200 - 5 - 10 - 50 - 0);
        });
}

#[test]
fn signed_extension_transaction_payment_multiplied_refund_works() {
    ExtBuilder::default()
        .balance_factor(10)
        .base_weight(5)
        .build()
        .execute_with(|| {
            let len = 10;
            TransactionPayment::put_next_fee_multiplier(Multiplier::saturating_from_rational(3, 2));

            let pre = ChargeTransactionPayment::<Runtime>::from(0 /* tipped */)
                .pre_dispatch(&2, CALL, &info_from_weight(100), len)
                .unwrap();
            // 5 base fee, 10 byte fee, 3/2 * 100 weight fee, 5 tip
            assert_eq!(Balances::free_balance(2), 200 - 5 - 10 - 150 - 0);

            assert!(ChargeTransactionPayment::<Runtime>::post_dispatch(
                pre,
                &info_from_weight(100),
                &post_info_from_weight(50),
                len,
                &Ok(())
            )
            .is_ok());
            // 75 (3/2 of the returned 50 units of weight) is refunded
            assert_eq!(Balances::free_balance(2), 200 - 5 - 10 - 75 - 0);
        });
}

#[test]
fn signed_extension_transaction_payment_is_bounded() {
    ExtBuilder::default()
        .balance_factor(1000)
        .byte_fee(0)
        .build()
        .execute_with(|| {
            // maximum weight possible
            assert!(ChargeTransactionPayment::<Runtime>::from(0)
                .pre_dispatch(&1, CALL, &info_from_weight(Weight::max_value()), 10)
                .is_ok());
            // fee will be proportional to what is the actual maximum weight in the runtime.
            assert_eq!(
                Balances::free_balance(&1),
                (10000 - <Runtime as frame_system::Trait>::MaximumBlockWeight::get()) as u128
            );
        });
}

#[test]
fn signed_extension_allows_free_transactions() {
    ExtBuilder::default()
        .base_weight(100)
        .balance_factor(0)
        .build()
        .execute_with(|| {
            // 1 ain't have a penny.
            assert_eq!(Balances::free_balance(1), 0);

            let len = 100;

            // This is a completely free (and thus wholly insecure/DoS-ridden) transaction.
            let operational_transaction = DispatchInfo {
                weight: 0,
                class: DispatchClass::Operational,
                pays_fee: Pays::No,
            };
            assert!(ChargeTransactionPayment::<Runtime>::from(0)
                .validate(&1, CALL, &operational_transaction, len)
                .is_ok());

            // like a InsecureFreeNormal
            let free_transaction = DispatchInfo {
                weight: 0,
                class: DispatchClass::Normal,
                pays_fee: Pays::Yes,
            };
            assert!(ChargeTransactionPayment::<Runtime>::from(0)
                .validate(&1, CALL, &free_transaction, len)
                .is_err());
        });
}

#[test]
fn signed_ext_length_fee_is_also_updated_per_congestion() {
    ExtBuilder::default()
        .base_weight(5)
        .balance_factor(10)
        .build()
        .execute_with(|| {
            // all fees should be x1.5
            TransactionPayment::put_next_fee_multiplier(Multiplier::saturating_from_rational(3, 2));
            let len = 10;

            assert!(ChargeTransactionPayment::<Runtime>::from(0) // tipped
                .pre_dispatch(&1, CALL, &info_from_weight(3), len)
                .is_ok());
            assert_eq!(
                Balances::free_balance(1),
                100 // original
                    - 0 // tip
                    - 5 // base
                    - 10 // len
                    - (3 * 3 / 2) // adjusted weight
            );
        })
}

#[test]
fn query_info_works() {
    let call = Call::Balances(BalancesCall::transfer(2, 69));
    let origin = 111111;
    let extra = ();
    let xt = TestXt::new(call, Some((origin, extra)));
    let info = xt.get_dispatch_info();
    let ext = xt.encode();
    let len = ext.len() as u32;
    ExtBuilder::default()
        .base_weight(5)
        .weight_fee(2)
        .build()
        .execute_with(|| {
            // all fees should be x1.5
            TransactionPayment::put_next_fee_multiplier(Multiplier::saturating_from_rational(3, 2));

            assert_eq!(
                TransactionPayment::query_info(xt, len),
                RuntimeDispatchInfo {
                    weight: info.weight,
                    class: info.class,
                    partial_fee: 5 * 2 /* base * weight_fee */
                           + len as u128  /* len * 1 */
                           + info.weight.min(MaximumBlockWeight::get()) as u128 * 2 * 3 / 2 /* weight */
                },
            );
        });
}

#[test]
fn compute_fee_works_without_multiplier() {
    ExtBuilder::default()
        .base_weight(100)
        .byte_fee(10)
        .balance_factor(0)
        .build()
        .execute_with(|| {
            // Next fee multiplier is zero
            assert_eq!(TransactionPayment::next_fee_multiplier(), Multiplier::one());

            // Tip only, no fees works
            let dispatch_info = DispatchInfo {
                weight: 0,
                class: DispatchClass::Operational,
                pays_fee: Pays::No,
            };
            assert_eq!(TransactionPayment::compute_fee(0, &dispatch_info, 10), 10);
            // No tip, only base fee works
            let dispatch_info = DispatchInfo {
                weight: 0,
                class: DispatchClass::Operational,
                pays_fee: Pays::Yes,
            };
            assert_eq!(TransactionPayment::compute_fee(0, &dispatch_info, 0), 100);
            // Tip + base fee works
            assert_eq!(TransactionPayment::compute_fee(0, &dispatch_info, 69), 169);
            // Len (byte fee) + base fee works
            assert_eq!(TransactionPayment::compute_fee(42, &dispatch_info, 0), 520);
            // Weight fee + base fee works
            let dispatch_info = DispatchInfo {
                weight: 1000,
                class: DispatchClass::Operational,
                pays_fee: Pays::Yes,
            };
            assert_eq!(TransactionPayment::compute_fee(0, &dispatch_info, 0), 1100);
        });
}

#[test]
fn compute_fee_works_with_multiplier() {
    ExtBuilder::default()
        .base_weight(100)
        .byte_fee(10)
        .balance_factor(0)
        .build()
        .execute_with(|| {
            // Add a next fee multiplier. Fees will be x3/2.
            TransactionPayment::put_next_fee_multiplier(Multiplier::saturating_from_rational(3, 2));
            // Base fee is unaffected by multiplier
            let dispatch_info = DispatchInfo {
                weight: 0,
                class: DispatchClass::Operational,
                pays_fee: Pays::Yes,
            };
            assert_eq!(TransactionPayment::compute_fee(0, &dispatch_info, 0), 100);

            // Everything works together :)
            let dispatch_info = DispatchInfo {
                weight: 123,
                class: DispatchClass::Operational,
                pays_fee: Pays::Yes,
            };
            // 123 weight, 456 length, 100 base
            assert_eq!(
                TransactionPayment::compute_fee(456, &dispatch_info, 789),
                100 + (3 * 123 / 2) + 4560 + 789,
            );
        });
}

#[test]
fn compute_fee_works_with_negative_multiplier() {
    ExtBuilder::default()
        .base_weight(100)
        .byte_fee(10)
        .balance_factor(0)
        .build()
        .execute_with(|| {
            // Add a next fee multiplier. All fees will be x1/2.
            TransactionPayment::put_next_fee_multiplier(Multiplier::saturating_from_rational(1, 2));

            // Base fee is unaffected by multiplier.
            let dispatch_info = DispatchInfo {
                weight: 0,
                class: DispatchClass::Operational,
                pays_fee: Pays::Yes,
            };
            assert_eq!(TransactionPayment::compute_fee(0, &dispatch_info, 0), 100);

            // Everything works together.
            let dispatch_info = DispatchInfo {
                weight: 123,
                class: DispatchClass::Operational,
                pays_fee: Pays::Yes,
            };
            // 123 weight, 456 length, 100 base
            assert_eq!(
                TransactionPayment::compute_fee(456, &dispatch_info, 789),
                100 + (123 / 2) + 4560 + 789,
            );
        });
}

#[test]
fn compute_fee_does_not_overflow() {
    ExtBuilder::default()
        .base_weight(100)
        .byte_fee(10)
        .balance_factor(0)
        .build()
        .execute_with(|| {
            // Overflow is handled
            let dispatch_info = DispatchInfo {
                weight: Weight::max_value(),
                class: DispatchClass::Operational,
                pays_fee: Pays::Yes,
            };
            assert_eq!(
                TransactionPayment::compute_fee(
                    <u32>::max_value(),
                    &dispatch_info,
                    <u128>::max_value()
                ),
                <u128>::max_value()
            );
        });
}

#[test]
fn actual_weight_higher_than_max_refunds_nothing() {
    ExtBuilder::default()
        .balance_factor(10)
        .base_weight(5)
        .build()
        .execute_with(|| {
            let len = 10;
            let pre = ChargeTransactionPayment::<Runtime>::from(0 /* tipped */)
                .pre_dispatch(&2, CALL, &info_from_weight(100), len)
                .unwrap();
            assert_eq!(Balances::free_balance(2), 200 - 0 - 10 - 100 - 5);

            assert!(ChargeTransactionPayment::<Runtime>::post_dispatch(
                pre,
                &info_from_weight(100),
                &post_info_from_weight(101),
                len,
                &Ok(())
            )
            .is_ok());
            assert_eq!(Balances::free_balance(2), 200 - 0 - 10 - 100 - 5);
        });
}

#[test]
fn zero_transfer_on_free_transaction() {
    ExtBuilder::default()
        .balance_factor(10)
        .base_weight(5)
        .build()
        .execute_with(|| {
            // So events are emitted
            System::set_block_number(10);
            let len = 10;
            let dispatch_info = DispatchInfo {
                weight: 100,
                pays_fee: Pays::No,
                class: DispatchClass::Normal,
            };
            let user = 69;
            let pre = ChargeTransactionPayment::<Runtime>::from(0)
                .pre_dispatch(&user, CALL, &dispatch_info, len)
                .unwrap();
            assert_eq!(Balances::total_balance(&user), 0);
            assert!(ChargeTransactionPayment::<Runtime>::post_dispatch(
                pre,
                &dispatch_info,
                &default_post_info(),
                len,
                &Ok(())
            )
            .is_ok());
            assert_eq!(Balances::total_balance(&user), 0);
            // No events for such a scenario
            assert_eq!(System::events().len(), 0);
        });
}

#[test]
fn refund_consistent_with_actual_weight() {
    ExtBuilder::default()
        .balance_factor(10)
        .base_weight(7)
        .build()
        .execute_with(|| {
            let info = info_from_weight(100);
            let post_info = post_info_from_weight(33);
            let prev_balance = Balances::free_balance(2);
            let len = 10;
            let tip = 0;

            TransactionPayment::put_next_fee_multiplier(Multiplier::saturating_from_rational(5, 4));

            let pre = ChargeTransactionPayment::<Runtime>::from(tip)
                .pre_dispatch(&2, CALL, &info, len)
                .unwrap();

            ChargeTransactionPayment::<Runtime>::post_dispatch(
                pre,
                &info,
                &post_info,
                len,
                &Ok(()),
            )
            .unwrap();

            let refund_based_fee = prev_balance - Balances::free_balance(2);
            let actual_fee =
                TransactionPayment::compute_actual_fee(len as u32, &info, &post_info, tip);

            // 33 weight, 10 length, 7 base, 5 tip
            assert_eq!(actual_fee, 7 + 10 + (33 * 5 / 4) + tip);
            assert_eq!(refund_based_fee, actual_fee);
        });
}
